(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{88:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return p}));var r=n(2),a=n(6),o=(n(0),n(97)),l={title:"Server Side Rendering"},i={unversionedId:"recipes/server-side-rendering",id:"recipes/server-side-rendering",isDocsHomePage:!1,title:"Server Side Rendering",description:"Apollo provides two techniques to allow your applications to load quickly, avoiding unnecessary delays to users:",source:"@site/docs/recipes/server-side-rendering.md",permalink:"/docs/recipes/server-side-rendering",editUrl:"https://github.com/kamilkisiela/apollo-angular/edit/master/website/docs/recipes/server-side-rendering.md",version:"next",sidebar:"docs",previous:{title:"Prefetching data",permalink:"/docs/recipes/prefetching"},next:{title:"Webpack loader",permalink:"/docs/recipes/webpack"}},s=[{value:"Server-side rendering",id:"server-side-rendering",children:[]},{value:"Store rehydration",id:"store-rehydration",children:[]},{value:"Http Caching",id:"http-caching",children:[]},{value:"Best Practices",id:"best-practices",children:[]},{value:"Example",id:"example",children:[]}],c={rightToc:s};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Apollo provides two techniques to allow your applications to load quickly, avoiding unnecessary delays to users:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Store rehydration, which allows your initial set of queries to return data immediately without a server roundtrip."),Object(o.b)("li",{parentName:"ul"},"Server side rendering, which renders the initial HTML view on the server before sending it to the client.")),Object(o.b)("p",null,"You can use one or both of these techniques to provide a better user experience."),Object(o.b)("h4",{id:"creating-a-client"},"Creating a client"),Object(o.b)("p",null,"Before we dive more into SSR, let's create an example to work on."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"// Angular\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\n// Apollo\nimport { ApolloModule, Apollo } from 'apollo-angular';\nimport { HttpLinkModule, HttpLink } from 'apollo-angular-link-http';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n\n@NgModule({\n  imports: [\n    // ...\n    BrowserModule,\n    HttpClientModule,\n    ApolloModule,\n    HttpLinkModule\n  ],\n  // ...\n})\nclass AppModule {\n  cache: InMemoryCache;\n\n  constructor(\n    apollo: Apollo,\n    httpLink: HttpLink\n  ) {\n    this.cache = new InMemoryCache();\n\n    apollo.create({\n      link: httpLink.create({ uri: '/graphql' }),\n      cache: this.cache,\n    });\n  }\n}\n")),Object(o.b)("h2",{id:"server-side-rendering"},"Server-side rendering"),Object(o.b)("p",null,"You can render your entire Angular-based Apollo application on a Node server the same way as you would normally do with an Angular app."),Object(o.b)("p",null,"No changes are required to client queries to support this, so your Apollo-based Angular UI should support SSR out of the box."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"SSR works out of the box when using ",Object(o.b)("inlineCode",{parentName:"p"},"HttpLink")," from ",Object(o.b)("inlineCode",{parentName:"p"},"apollo-angular-link-http")," because it uses Angular's ",Object(o.b)("inlineCode",{parentName:"p"},"HttpClient")," internally.\nThis would't be that easy with ",Object(o.b)("inlineCode",{parentName:"p"},"apollo-link-http"),". That non-angular Link uses Fetch API which would have to schedule a macroTask (Zone.js) so Angular could wait for the request to finish.")),Object(o.b)("h2",{id:"store-rehydration"},"Store rehydration"),Object(o.b)("p",null,'For applications that can perform some queries on the server prior to rendering the UI on the client, Apollo allows for setting the initial state of data. This is sometimes called rehydration, since the data is "dehydrated" when it is serialized and included in the initial HTML payload.'),Object(o.b)("p",null,"For example, a typical approach is to use ",Object(o.b)("inlineCode",{parentName:"p"},"TransferState")," and ",Object(o.b)("inlineCode",{parentName:"p"},"BrowserTransferStateModule")," so you can then rehydrate the client using the initial state passed from the server:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"// Angular\nimport { NgModule } from '@angular/core';\nimport { BrowserModule, BrowserTransferStateModule, TransferState, makeStateKey } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\n// Apollo\nimport { ApolloModule, Apollo } from 'apollo-angular';\nimport { HttpLinkModule, HttpLink } from 'apollo-angular-link-http';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n\nconst STATE_KEY = makeStateKey<any>('apollo.state');\n\n@NgModule({\n  imports: [\n    // ...\n    BrowserModule,\n    HttpClientModule,\n    ApolloModule,\n    HttpLinkModule\n  ],\n  // ...\n})\nclass AppModule {\n  cache: InMemoryCache;\n\n  constructor(\n    apollo: Apollo,\n    httpLink: HttpLink,\n    private readonly transferState: TransferState,\n  ) {\n    this.cache = new InMemoryCache();\n\n    apollo.create({\n      link: httpLink.create({ uri: '/graphql' }),\n      cache: this.cache,\n    });\n\n    const isBrowser = this.transferState.hasKey<any>(STATE_KEY);\n\n    if (isBrowser) {\n      this.onBrowser();\n    } else {\n      this.onServer();\n    }\n  }\n\n  onServer() {\n    this.transferState.onSerialize(STATE_KEY, () => {\n      return this.cache.extract();\n    });\n  }\n\n  onBrowser() {\n    const state = this.transferState.get<any>(STATE_KEY, null);\n\n    this.cache.restore(state);\n  }\n}\n")),Object(o.b)("p",null,"Adding store rehydration to your app is straightforward since Angular itself has a mechanism to transfer data from server to client."),Object(o.b)("p",null,"Let's explain step by step how we implemented store rehydration in the example."),Object(o.b)("p",null,"First, we imported ",Object(o.b)("inlineCode",{parentName:"p"},"BrowserTransferStateModule")," from ",Object(o.b)("inlineCode",{parentName:"p"},"@angular/platform-browser"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"import { BrowserTransferStateModule } from '@angular/platform-browser';\n\n@NgModule({ ... })\nclass AppModule {}\n")),Object(o.b)("p",null,"Then we created a ",Object(o.b)("inlineCode",{parentName:"p"},"STATE_KEY")," which allows to attach data to it:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"import { makeStateKey } from '@angular/platform-browser';\n\nconst STATE_KEY = makeStateKey<any>('apollo.state');\n")),Object(o.b)("p",null,"Now we can implement some logic by using ",Object(o.b)("inlineCode",{parentName:"p"},"TransferState"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"import { TransferState } from '@angular/platform-browser';\n\n@NgModule({ ... })\nclass AppModule {\n  // ...\n  constructor(\n    // ...\n    private readonly transferState: TransferState\n  ) {\n    // ...\n\n    const isBrowser = this.transferState.hasKey<any>(STATE_KEY);\n\n    if (isBrowser) {\n      this.onBrowser();\n    } else {\n      this.onServer();\n    }\n  }\n}\n")),Object(o.b)("p",null,"About ",Object(o.b)("inlineCode",{parentName:"p"},"isBrowser"),", ",Object(o.b)("inlineCode",{parentName:"p"},"this.transferState.hasKey<any>(STATE_KEY)")," will return a value only if it runs within a browser, on the client side."),Object(o.b)("p",null,"Here is an interesting part, the actual store rehydration."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"@NgModule({ ... })\nclass AppModule {\n  onServer() {\n    this.transferState.onSerialize(STATE_KEY, () =>\n      this.cache.extract()\n    );\n  }\n\n  onBrowser() {\n    const state = this.transferState.get<any>(STATE_KEY, null);\n\n    this.cache.restore(state);\n  }\n}\n")),Object(o.b)("p",null,"In ",Object(o.b)("inlineCode",{parentName:"p"},"onServer")," we extract data from cache when TransferState says it is ready to save and serialize data.\nIn ",Object(o.b)("inlineCode",{parentName:"p"},"OnBrowser")," we do opposite thing, we receive transfered data to restore cache."),Object(o.b)("p",null,"Super easy and clean!"),Object(o.b)("p",null,"With all this when the client runs the first set of queries, the data will be returned instantly because it is already in the store!"),Object(o.b)("p",null,"If you are using ",Object(o.b)("inlineCode",{parentName:"p"},"forceFetch")," on some of the initial queries, you can pass the ",Object(o.b)("inlineCode",{parentName:"p"},"ssrForceFetchDelay")," option to skip force fetching during initialization, so that even those queries run using the cache:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"// to use it create two Apollo Clients\nconst cache = new InMemoryCache();\n\n// one for client side\napollo.create({\n  cache: cache.restore(window.__APOLLO_STATE__),\n  link,\n  ssrForceFetchDelay: 100,\n});\n\n// and second one for server\napollo.create({\n  cache,\n  link,\n});\n")),Object(o.b)("h2",{id:"http-caching"},"Http Caching"),Object(o.b)("p",null,"As you know, ",Object(o.b)("inlineCode",{parentName:"p"},"HttpLink")," from ",Object(o.b)("inlineCode",{parentName:"p"},"apollo-angular-link-http")," package uses Angular's ",Object(o.b)("inlineCode",{parentName:"p"},"HttpClient")," to make requests. Thanks to that and ",Object(o.b)("inlineCode",{parentName:"p"},"@nguniversal/common")," it is super easy to make SSR working without even writing a single line of code."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"TransferHttpCacheModule"),", which is a part of ",Object(o.b)("inlineCode",{parentName:"p"},"@nguniversal/common"),", intercepts ",Object(o.b)("inlineCode",{parentName:"p"},"HttpClient")," requests on the server and store the response in the ",Object(o.b)("inlineCode",{parentName:"p"},"TransferState")," key-value store. This is transferred to the client, which then uses it to respond to the same ",Object(o.b)("inlineCode",{parentName:"p"},"HttpClient")," requests on the client."),Object(o.b)("p",null,"Here you can see how simple is that:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\n// SSR\nimport { TransferHttpCacheModule } from '@nguniversal/common';\nimport { ApolloModule, Apollo } from 'apollo-angular';\nimport { HttpLinkModule, HttpLink } from 'apollo-angular-link-http';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n\n@NgModule({\n  imports: [\n    // ...\n    BrowserModule,\n    TransferHttpCacheModule,\n    HttpClientModule,\n    ApolloModule,\n    HttpLinkModule\n  ],\n  // ...\n})\nclass AppModule {\n  constructor(\n    apollo: Apollo,\n    httpLink: HttpLink\n  ) {\n    apollo.create({\n      link: httpLink.create({ uri: '/graphql' }),\n      cache: new InMemoryCache(),\n    });\n  }\n}\n")),Object(o.b)("h2",{id:"best-practices"},"Best Practices"),Object(o.b)("p",null,"You saw how to use Server-Side Rendering and Store Rehydration in your application, but you will need to be a little careful in how you create Apollo on the server to ensure everything works there as well:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"When ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/basics/setup"}),"creating Apollo")," (",Object(o.b)("inlineCode",{parentName:"p"},"Apollo.create"),") on the server, you'll need to set up your HttpLink to connect to the API server correctly. This might look different to how you do it on the client, since you'll probably have to use an absolute URL to the server if you were using a relative URL on the client.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Since you only want to fetch each query result once, pass the ",Object(o.b)("inlineCode",{parentName:"p"},"ssrMode: true")," option to the ",Object(o.b)("inlineCode",{parentName:"p"},"Apollo.create")," to avoid repeated force-fetching.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"You need to ensure that you create a new client or store instance for each request, rather than re-using the same client for multiple requests. Otherwise the UI will be getting stale data and you'll have problems with ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/recipes/authentication"}),"authentication"),"."))),Object(o.b)("h2",{id:"example"},"Example"),Object(o.b)("p",null,"You can ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/kamilkisiela/apollo-angular-ssr"}),"take a look")," on a simple example with the implementation we talked about."))}p.isMDXComponent=!0},97:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),p=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},b=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),b=r,h=u["".concat(l,".").concat(b)]||u[b]||d[b]||o;return n?a.a.createElement(h,i(i({ref:t},c),{},{components:n})):a.a.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=b;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var c=2;c<o;c++)l[c]=n[c];return a.a.createElement.apply(null,l)}return a.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);